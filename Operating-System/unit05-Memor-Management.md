

# üß† Unit 5: Memory Management

## üíæ Topic 1: Basic Concepts and Contiguous Allocation

### **Introduction: The Space Organizer** üì¶

**Memory Management** is the OS function responsible for handling and coordinating the primary memory (RAM). It decides which process gets which memory space and translates the addresses used by the programmer into the actual physical addresses in the hardware.

### **Core Concepts** üìù

* **Logical Address (Virtual Address):** The address generated by the CPU and used by the program. This is the address the programmer sees. (e.g., The house number written on a letter).
* **Physical Address (Real Address):** The actual address of the memory location in the main memory (RAM). This is the address seen by the memory unit. (e.g., The location of the actual house on the physical land).
* **Memory Management Unit (MMU):** The hardware device that translates the **Logical Address** into the **Physical Address** at runtime.
* **Binding:** The process of mapping program instructions and data to physical memory addresses.



### **Contiguous Memory Allocation** üß±

* **Concept:** Each process is allocated a **single, contiguous block** of memory. It must occupy a continuous section of RAM.
* **Methods:**
    * **Fixed Partitioning (Static):** RAM is divided into fixed-size partitions (e.g., 4MB, 8MB, 4MB). Each partition holds exactly one process.
        * **Problem:** **Internal Fragmentation** (wasted space *inside* a partition because the process size is smaller than the partition size).
    * **Variable Partitioning (Dynamic):** RAM is initially one large block. When a process arrives, a partition exactly its size is created. When it terminates, the memory is released.
        * **Problem:** **External Fragmentation** (memory is available, but it is scattered in small, non-contiguous pieces, so a large process cannot be loaded).

### **Fragmentation and Compaction** üíî

* **Internal Fragmentation:** Unused memory space **within** a process's allocated block. (e.g., a process needs 3MB but is allocated a 4MB block). **Fixed Partitioning** is prone to this.
* **External Fragmentation:** Total free memory exists to satisfy a request, but it is not **contiguous**. (e.g., total free space is 10MB, but in 5 pieces of 2MB each). **Variable Partitioning** is prone to this.
* **Compaction:** A solution to External Fragmentation. It involves shuffling all loaded processes in memory to bring all free space together into one large block.
    * **Cost:** Very expensive in terms of CPU time and overhead, as all process addresses must be dynamically relocated.

### **Tips to Memorize** ‚ú®

* **Fragmentation Distinction:** **Internal** is **In**side the block; **External** is **Out**side/between blocks.

---

## üìÑ Topic 2: Paging

### **Introduction: Breaking It Up** üß©

**Paging** is a memory management technique that solves the problem of external fragmentation by allowing a process's physical address space to be **non-contiguous**.

### **Principle of Operation** ‚öôÔ∏è

* **Physical Memory $\rightarrow$ Frames:** Physical memory is divided into fixed-size blocks called **frames** (or page frames).
* **Logical Memory $\rightarrow$ Pages:** Logical memory (the process's address space) is divided into blocks of the **same size** called **pages**.
* **Mapping:** The OS ensures that the size of a page is equal to the size of a frame.
* **How It Works:** When a process is loaded, its pages are scattered and placed into any available free frames in physical memory.

#### **Address Translation with Paging**
1.  The CPU generates a **Logical Address** which is split into two parts:
    * **Page Number ($P$):** Used as an index into the **Page Table**.
    * **Page Offset ($D$):** The displacement/address within the page/frame.
2.  The **Page Table** (managed by the OS) holds the **Base Address** (or **Frame Number, $F$)** of the physical frame where the page $P$ is loaded.
3.  The **Physical Address** is generated by concatenating the **Frame Number ($F$)** with the **Page Offset ($D$)**.
$$\text{Physical Address} = \text{Frame Number} || \text{Page Offset}$$



### **Hardware Support for Paging** üõ†Ô∏è

* **Page Table:** A crucial data structure. It can be implemented using dedicated registers or in main memory.
* **Translation Lookaside Buffer (TLB):** A small, fast, hardware **cache** used to speed up the translation process. It stores the most recently used **Page Number $\rightarrow$ Frame Number** mappings.
    * If the mapping is found in the TLB (**TLB Hit**), the physical address is generated very fast.
    * If it's not found (**TLB Miss**), the OS must consult the main Page Table (slower).

### **Protection and Sharing** üõ°Ô∏è

* **Protection:** Each entry in the Page Table can have a **protection bit** (e.g., read-only, read/write) associated with it, ensuring a process cannot accidentally or intentionally write to pages it should only read.
* **Sharing:** Multiple processes can share common code (like a system library or editor) by simply having entries in their respective **Page Tables** pointing to the **same set of physical frames**. This saves memory.

### **Disadvantages of Paging** üëé

* **Internal Fragmentation:** While External Fragmentation is eliminated, Paging still suffers from minor **Internal Fragmentation** because the last page of a process may not be full.
* **Overhead:** Maintaining and managing the Page Table itself requires extra memory space and increases the complexity of the OS.
* **Time Consumption (Speed):** Accessing memory involves **two** memory accesses (one for the Page Table entry, one for the data). This slows down performance, mitigated by the TLB.

---

## ‚òÅÔ∏è Topic 3: Virtual Memory

### **Introduction: The Illusion of Infinity** üåå

**Virtual Memory** is a technique that separates the user's logical memory from physical memory. The central idea is that a process can execute even if only a fraction of its pages are actually loaded into physical memory. It creates the illusion that the program has an infinitely large memory space.

### **Basics of Virtual Memory** üí°

* **Locality of Reference:** The principle that makes Virtual Memory possible. It states that during any phase of execution, a program tends to reference only a small portion of its address space (i.e., instructions and data are clustered).
* **Demand Paging:** The technique used to implement Virtual Memory. It loads a page into memory **only when it is needed** (demanded) during program execution, rather than loading the entire program upfront.

#### **Hardware and Control Structures**
* **Page Table (Revisited):** The page table entry now includes a crucial new bit:
    * **Valid/Invalid Bit:** If set to **'valid'**, the page is in physical memory. If set to **'invalid'**, the page is on the disk (not in RAM).
* **Dirty Page/Dirty Bit (D Bit):** A bit in the page table entry. If the page has been **modified** since it was loaded, the dirty bit is set to 1. If it's 0, the page is clean. This helps the OS decide if it needs to be written back to disk during replacement.

### **The Page Fault Mechanism** üí•

A **Page Fault** is an interrupt/trap raised by the hardware (MMU) when a process tries to access a page that is marked **'invalid'** (i.e., not in physical memory).

#### **Handling a Page Fault**
1.  The MMU traps to the OS kernel.
2.  The OS checks the process's internal tables to verify the memory access was valid.
3.  A free frame is located (if none, a **Page Replacement Algorithm** is triggered).
4.  A disk I/O request is scheduled to read the required page from the secondary storage (swap space) into the free frame.
5.  While the disk I/O occurs, the process is put into a **Waiting/Blocked** state, and the CPU is given to another process.
6.  Once the page is loaded, the Page Table is updated (Valid Bit set to 'valid').
7.  The instruction that caused the fault is restarted.

### **Working Set Model** üíº

* **Concept:** The set of pages that a process is currently actively using (its set of pages referenced in the last $\Delta$ time unit).
* **Goal:** The OS tries to ensure that a process's **entire working set is in physical memory** before running it. If the working set is kept in memory, the process is unlikely to suffer from repeated page faults, avoiding **thrashing**.
* **Thrashing:** A state where a process spends more time paging (swapping pages in and out) than executing instructions.

---

## üîÑ Topic 4: Page Replacement Algorithms

When a page fault occurs and no free frames are available, the OS must choose a **victim page** to remove from memory (to make space). This choice is governed by the Page Replacement Algorithm.

| Algorithm | Concept | Goal/Efficiency | Disadvantage |
| :--- | :--- | :--- | :--- |
| **Optimal (OPT)** | Replace the page that **will not be used for the longest period of time** in the future. | **Theoretically best** (lowest page fault rate). | Impossible to implement in reality (requires knowing the future). |
| **First-In, First-Out (FIFO)** | Replace the page that has been in memory for the **longest time** (the oldest page). | Simple to implement (uses a queue). | Suffers from **Belady's Anomaly** (increasing the number of frames increases the page fault rate). |
| **Second Chance (SC) / Clock** | FIFO with a twist. Uses a **Reference Bit (R Bit)**. The oldest page is checked: if $R=0$, it's replaced. If $R=1$, the bit is reset to 0, and the page is moved to the back of the FIFO queue (given a "second chance"). | Better than pure FIFO, avoids replacing recently used pages. | Still relies on the age of the page, not its actual frequency of use. |
| **Least Recently Used (LRU)** | Replace the page that has **not been used for the longest period of time** in the past. | Excellent approximation of OPT (based on the past predicting the future). Generally very good. | **Very expensive to implement** in hardware. Requires tracking the exact time/order of every page reference. |
| **Not Recently Used (NRU)** | A practical, cheaper approximation of LRU. It classifies pages into four classes based on the **Reference Bit (R)** and **Dirty Bit (D)**. | Simple and efficient. Prefers to replace clean, unreferenced pages. | Only uses the status since the last clock interrupt (approximate usage). |

